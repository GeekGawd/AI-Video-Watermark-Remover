<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Watermark Remover</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --bg: #f3f3f3;
        --text: #151515;
        --muted-text: #5d5d5d;
        --surface: #ffffff;
        --surface-muted: #ededed;
        --surface-strong: #e5e5e5;
        --border: rgba(0, 0, 0, 0.08);
        --shadow: 0 16px 40px rgba(0, 0, 0, 0.08);
        --button-bg: #151515;
        --button-text: #f7f7f7;
        --button-hover-bg: #000000;
        --button-disabled-bg: #c7c7c7;
        --button-disabled-text: #6a6a6a;
      }
      [data-theme="dark"] {
        --bg: #050505;
        --text: #f5f5f5;
        --muted-text: #b5b5b5;
        --surface: #101010;
        --surface-muted: #161616;
        --surface-strong: #1f1f1f;
        --border: rgba(255, 255, 255, 0.08);
        --shadow: 0 16px 40px rgba(0, 0, 0, 0.5);
        --button-bg: #f5f5f5;
        --button-text: #050505;
        --button-hover-bg: #d8d8d8;
        --button-disabled-bg: #2c2c2c;
        --button-disabled-text: #707070;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        transition: background 0.3s ease, color 0.3s ease;
      }
      .app { min-height: 100vh; padding: 24px; }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 40px;
      }
      .header-text { max-width: 520px; }
      .header-text h1 { font-size: 2.2rem; margin-bottom: 10px; font-weight: 700; }
      .header-text p { font-size: 1.05rem; color: var(--muted-text); }
      .theme-toggle {
        padding: 10px 20px;
        border-radius: 999px;
        background: var(--button-bg);
        color: var(--button-text);
        border: 1px solid transparent;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }
      .theme-toggle:hover { background: var(--button-hover-bg); transform: translateY(-1px); }
      .theme-toggle:focus-visible { outline: 2px solid var(--text); outline-offset: 3px; }
      .container { max-width: 1100px; margin: 0 auto; }
      .upload-section,
      .video-section,
      .output-section {
        background: var(--surface);
        border-radius: 16px;
        padding: 32px;
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
        margin-bottom: 30px;
      }
      .upload-section { text-align: center; }
      .upload-button {
        display: inline-block;
        padding: 12px 32px;
        background: var(--button-bg);
        color: var(--button-text);
        border-radius: 999px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .upload-button:hover { background: var(--button-hover-bg); transform: translateY(-1px); }
      .upload-button:focus-visible { outline: 2px solid var(--text); outline-offset: 3px; }
      .file-name { margin-left: 15px; color: var(--muted-text); font-size: 0.95rem; }
      .video-container { position: relative; width: 100%; max-width: 860px; margin: 0 auto 30px; border-radius: 12px; overflow: hidden; background: var(--surface-muted); border: 1px solid var(--border); }
      .video-container video { width: 100%; display: block; }
      .drawing-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
      .drawing-canvas.active { pointer-events: auto; cursor: crosshair; }
      .controls { max-width: 860px; margin: 0 auto; display: flex; flex-direction: column; gap: 20px; }
      .info {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        padding: 18px 22px;
        background: var(--surface-muted);
        border-radius: 12px;
        border: 1px solid var(--border);
      }
      .info p { font-size: 0.95rem; color: var(--text); font-weight: 500; }
      .info span { color: var(--muted-text); }
      .instructions,
      .regions-list {
        padding: 18px 22px;
        background: var(--surface-muted);
        border-radius: 12px;
        border: 1px solid var(--border);
      }
      .instructions p { margin: 6px 0; color: var(--muted-text); font-size: 0.92rem; }
      .regions-list { display: flex; flex-direction: column; gap: 12px; }
      .regions-list h3 { margin: 0; color: var(--text); font-size: 1rem; font-weight: 600; }
      .regions-list ul { margin: 0; padding-left: 18px; display: flex; flex-direction: column; gap: 6px; color: var(--muted-text); font-size: 0.9rem; }
      .button-group { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
      button {
        padding: 12px 22px;
        font-size: 0.95rem;
        font-weight: 600;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
        border: 1px solid transparent;
        background: var(--button-bg);
        color: var(--button-text);
      }
      button:hover:not(:disabled) { background: var(--button-hover-bg); transform: translateY(-1px); }
      button:focus-visible { outline: 2px solid var(--text); outline-offset: 3px; }
      button:disabled {
        background: var(--button-disabled-bg);
        color: var(--button-disabled-text);
        cursor: not-allowed;
        transform: none;
      }
      .process-button { min-width: 220px; }
      .toggle-on { background: var(--text); color: var(--button-text); }
      .progress-section {
        background: var(--surface-muted);
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px;
        border: 1px solid var(--border);
      }
      .progress-bar-container {
        width: 100%;
        height: 24px;
        background: var(--surface-strong);
        border-radius: 12px;
        overflow: hidden;
        margin: 12px 0;
        border: 1px solid var(--border);
      }
      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--button-bg), var(--text));
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--button-text);
        font-size: 0.85rem;
        font-weight: 600;
      }
      .progress-text {
        text-align: center;
        color: var(--muted-text);
        font-size: 0.9rem;
        margin-top: 8px;
      }
      .connectivity-banner {
        background: var(--surface);
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 16px 24px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 600;
      }
      .connectivity-banner.error {
        background: #fee;
        border-color: #fcc;
        color: #c33;
      }
      .connectivity-banner.success {
        background: #efe;
        border-color: #cfc;
        color: #3a3;
      }
      .connectivity-banner.checking {
        background: var(--surface-muted);
        color: var(--muted-text);
      }
      .output-section { text-align: center; }
      .output-section h2 { color: var(--text); margin-bottom: 20px; font-size: 1.4rem; }
      .download-button {
        display: inline-block;
        padding: 12px 40px;
        background: var(--button-bg);
        color: var(--button-text);
        text-decoration: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        transition: background 0.2s ease, transform 0.2s ease;
      }
      .download-button:hover { background: var(--button-hover-bg); transform: translateY(-1px); }
      .download-button:focus-visible { outline: 2px solid var(--text); outline-offset: 3px; }
      @media (max-width: 768px) {
        .app { padding: 20px; }
        .header { flex-direction: column; align-items: center; text-align: center; }
        .header-text { max-width: none; }
        .header-text h1 { font-size: 1.9rem; }
        .info { flex-direction: column; align-items: center; text-align: center; }
        .button-group { flex-direction: column; }
        button { width: 100%; }
        .theme-toggle { width: 100%; }
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="app">
      <header class="header">
        <div class="header-text">
          <h1>AI Watermark Remover</h1>
          <p>Upload a video, mark watermark regions, and remove them with AI</p>
        </div>
        <button id="theme-toggle" class="theme-toggle" aria-pressed="false" aria-label="Toggle dark mode">Dark Mode</button>
      </header>

      <div class="container">
        <div id="connectivity-banner" class="connectivity-banner checking" style="display:none;">
          Checking backend connectivity...
        </div>
        
        <div class="upload-section">
          <input type="file" id="video-upload" accept="video/*" style="display:none" />
          <label for="video-upload" class="upload-button">Choose Video</label>
          <span id="file-name" class="file-name"></span>
        </div>

        <div id="video-section" class="video-section" style="display:none;">
          <div class="video-container">
            <video id="video" controls crossorigin="anonymous"></video>
            <canvas id="canvas" class="drawing-canvas"></canvas>
          </div>

          <div class="controls">
            <div class="info">
              <p>Duration: <span id="duration">0:00</span></p>
              <p>Regions marked: <span id="region-count">0</span></p>
            </div>

            <div class="instructions">
              <p>Toggle Draw Mode to mark watermark boxes. When off, you can seek and play the video.</p>
              <p>Each region will be processed throughout the entire video.</p>
            </div>

            <div id="regions-list" class="regions-list" style="display:none;">
              <h3>Marked Regions:</h3>
              <ul id="regions-ul"></ul>
            </div>

            <div class="button-group">
              <button id="toggle-draw" aria-pressed="false">Draw Mode: Off</button>
              <button id="undo" disabled>Undo Last</button>
              <button id="clear" disabled>Clear All</button>
              <button id="process" class="process-button" disabled>Remove Watermarks</button>
            </div>
            
            <div id="progress-section" class="progress-section" style="display:none;">
              <div class="progress-bar-container">
                <div id="progress-bar" class="progress-bar" style="width: 0%;">0%</div>
              </div>
              <div id="progress-text" class="progress-text">Initializing...</div>
            </div>
          </div>
        </div>

        <div id="output-section" class="output-section" style="display:none;">
          <h2>Processed Video Ready!</h2>
          <a id="download-link" class="download-button" download="processed_video.mp4">Download Processed Video</a>
        </div>
      </div>
    </div>

    <script>
      (function() {
        const uploadInput = document.getElementById('video-upload');
        const fileNameEl = document.getElementById('file-name');
        const videoSection = document.getElementById('video-section');
        const videoEl = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const durationEl = document.getElementById('duration');
        const regionCountEl = document.getElementById('region-count');
        const regionsList = document.getElementById('regions-list');
        const regionsUl = document.getElementById('regions-ul');
        const toggleDrawBtn = document.getElementById('toggle-draw');
        const undoBtn = document.getElementById('undo');
        const clearBtn = document.getElementById('clear');
        const processBtn = document.getElementById('process');
        const outputSection = document.getElementById('output-section');
        const downloadLink = document.getElementById('download-link');
        const themeToggle = document.getElementById('theme-toggle');
        const connectivityBanner = document.getElementById('connectivity-banner');
        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        const BACKEND_URL = 'http://localhost:8000';

        function setTheme(mode) {
          document.body.setAttribute('data-theme', mode);
          if (themeToggle) {
            const isDark = mode === 'dark';
            themeToggle.textContent = isDark ? 'Light Mode' : 'Dark Mode';
            themeToggle.setAttribute('aria-pressed', isDark ? 'true' : 'false');
          }
        }

        const prefersDarkScheme = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
        const storedTheme = localStorage.getItem('app-theme');
        const initialTheme = storedTheme || (prefersDarkScheme && prefersDarkScheme.matches ? 'dark' : 'light');
        setTheme(initialTheme);

        if (themeToggle) {
          themeToggle.addEventListener('click', () => {
            const current = document.body.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
            const nextTheme = current === 'dark' ? 'light' : 'dark';
            setTheme(nextTheme);
            localStorage.setItem('app-theme', nextTheme);
          });
        }

        function handleSchemeChange(event) {
          if (localStorage.getItem('app-theme')) return;
          setTheme(event.matches ? 'dark' : 'light');
        }

        if (prefersDarkScheme) {
          if (typeof prefersDarkScheme.addEventListener === 'function') {
            prefersDarkScheme.addEventListener('change', handleSchemeChange);
          } else if (typeof prefersDarkScheme.addListener === 'function') {
            prefersDarkScheme.addListener(handleSchemeChange);
          }
        }

        const state = {
          videoFile: null,
          videoId: null,
          videoMeta: null,
          regions: [],
          isDrawing: false,
          drawStart: null,
          currentRegion: null,
          isProcessing: false,
          outputId: null,
          outputReady: false,
          drawMode: false,
          backendConnected: false,
          progressEventSource: null,
        };
        
        // Check backend connectivity on page load
        async function checkBackendConnectivity() {
          connectivityBanner.style.display = '';
          connectivityBanner.className = 'connectivity-banner checking';
          connectivityBanner.textContent = 'Checking backend connectivity...';
          
          try {
            const response = await fetch(`${BACKEND_URL}/health`, { 
              method: 'GET',
              signal: AbortSignal.timeout(5000)
            });
            
            if (response.ok) {
              const data = await response.json();
              state.backendConnected = true;
              connectivityBanner.className = 'connectivity-banner success';
              connectivityBanner.textContent = `Backend connected (Device: ${data.device})`;
              setTimeout(() => {
                connectivityBanner.style.display = 'none';
              }, 3000);
            } else {
              throw new Error('Backend returned error');
            }
          } catch (error) {
            state.backendConnected = false;
            connectivityBanner.className = 'connectivity-banner error';
            connectivityBanner.textContent = 'Backend not available. Please start the backend server.';
          }
        }
        
        // Check connectivity on load
        checkBackendConnectivity();

        function formatTime(seconds) {
          const s = Math.floor(seconds || 0);
          const m = Math.floor(s / 60);
          const rem = s % 60;
          return m + ':' + String(rem).padStart(2, '0');
        }

        function updateCanvasSize() {
          if (!videoEl || !canvas) return;
          // Match canvas pixel size to displayed video size for crisp drawing
          const w = videoEl.clientWidth;
          const h = videoEl.clientHeight;
          if (w && h) {
            canvas.width = w;
            canvas.height = h;
          }
        }

        function drawCanvas() {
          const ctx = canvas.getContext('2d');
          if (!ctx || !state.videoMeta) return;
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const scaleX = canvas.width / state.videoMeta.width;
          const scaleY = canvas.height / state.videoMeta.height;

          // Existing regions
          state.regions.forEach((region, index) => {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 3;
            ctx.fillRect(region.x * scaleX, region.y * scaleY, region.width * scaleX, region.height * scaleY);
            ctx.strokeRect(region.x * scaleX, region.y * scaleY, region.width * scaleX, region.height * scaleY);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('#' + (index + 1), region.x * scaleX + 5, region.y * scaleY + 20);
          });

          // Current region
          if (state.currentRegion) {
            const r = state.currentRegion;
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
            ctx.lineWidth = 2;
            ctx.fillRect(r.x * scaleX, r.y * scaleY, r.width * scaleX, r.height * scaleY);
            ctx.strokeRect(r.x * scaleX, r.y * scaleY, r.width * scaleX, r.height * scaleY);
          }
        }

        function updateUI() {
          regionCountEl.textContent = String(state.regions.length);
          undoBtn.disabled = state.regions.length === 0;
          clearBtn.disabled = state.regions.length === 0;
          processBtn.disabled = state.regions.length === 0 || state.isProcessing || !state.videoId;

          if (state.regions.length > 0) {
            regionsList.style.display = '';
            regionsUl.innerHTML = '';
            state.regions.forEach((r, idx) => {
              const li = document.createElement('li');
              li.textContent = `Region #${idx + 1}: Position (${Math.round(r.x)}, ${Math.round(r.y)}), Size ${Math.round(r.width)}x${Math.round(r.height)}px`;
              regionsUl.appendChild(li);
            });
          } else {
            regionsList.style.display = 'none';
            regionsUl.innerHTML = '';
          }

          toggleDrawBtn.textContent = state.drawMode ? 'Draw Mode: On' : 'Draw Mode: Off';
          toggleDrawBtn.classList.toggle('toggle-on', state.drawMode);
          toggleDrawBtn.setAttribute('aria-pressed', state.drawMode ? 'true' : 'false');

          if (state.videoMeta) {
            durationEl.textContent = formatTime(state.videoMeta.duration);
          } else {
            durationEl.textContent = '0:00';
          }

          if (state.outputReady && state.outputId) {
            outputSection.style.display = '';
            downloadLink.href = `${BACKEND_URL}/output/${state.outputId}`;
          } else {
            outputSection.style.display = 'none';
            downloadLink.removeAttribute('href');
          }
        }

        function setDrawMode(on) {
          state.drawMode = !!on;
          canvas.classList.toggle('active', state.drawMode);
          if (state.drawMode && !videoEl.paused) {
            try { videoEl.pause(); } catch (_) {}
          }
          updateUI();
        }

        function getEventCoords(e) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = state.videoMeta.width / rect.width;
          const scaleY = state.videoMeta.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          return { x, y };
        }

        // Upload handler
        uploadInput.addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          state.videoFile = file;
          fileNameEl.textContent = file.name;
          state.outputId = null;
          state.outputReady = false;
          state.regions = [];
          state.currentRegion = null;
          setDrawMode(false);
          updateUI();

          if (!state.backendConnected) {
            alert('Backend is not connected. Please start the backend server.');
            return;
          }
          
          const formData = new FormData();
          formData.append('file', file);
          try {
            const resp = await fetch(`${BACKEND_URL}/upload`, { method: 'POST', body: formData });
            if (!resp.ok) {
              const err = await resp.text();
              alert('Failed to upload video: ' + err);
              return;
            }
            const data = await resp.json();
            state.videoId = data.video_id;
            state.videoMeta = data;
            videoEl.src = `${BACKEND_URL}/video/${state.videoId}`;
            videoSection.style.display = '';
            updateUI();
          } catch (err) {
            alert('Upload error: ' + (err && err.message || err));
          }
        });

        // Video metadata loaded
        videoEl.addEventListener('loadedmetadata', () => {
          updateCanvasSize();
          drawCanvas();
        });

        // Redraw overlay when time updates (keeps overlay in sync)
        videoEl.addEventListener('timeupdate', drawCanvas);

        // Resize handling
        window.addEventListener('resize', () => { updateCanvasSize(); drawCanvas(); });

        // Drawing events (only when Draw Mode is ON)
        canvas.addEventListener('mousedown', (e) => {
          if (!state.drawMode || !state.videoMeta) return;
          const { x, y } = getEventCoords(e);
          state.isDrawing = true;
          state.drawStart = { x, y };
          state.currentRegion = null;
        });
        canvas.addEventListener('mousemove', (e) => {
          if (!state.drawMode || !state.isDrawing || !state.drawStart) return;
          const { x, y } = getEventCoords(e);
          const width = x - state.drawStart.x;
          const height = y - state.drawStart.y;
          state.currentRegion = {
            x: Math.min(state.drawStart.x, x),
            y: Math.min(state.drawStart.y, y),
            width: Math.abs(width),
            height: Math.abs(height),
          };
          drawCanvas();
        });
        function finishDraw() {
          if (!state.drawMode) return;
          if (state.currentRegion && state.currentRegion.width > 5 && state.currentRegion.height > 5) {
            const r = state.currentRegion;
            state.regions.push({
              x: Math.round(r.x),
              y: Math.round(r.y),
              width: Math.round(r.width),
              height: Math.round(r.height),
            });
          }
          state.isDrawing = false;
          state.drawStart = null;
          state.currentRegion = null;
          updateUI();
          drawCanvas();
        }
        canvas.addEventListener('mouseup', finishDraw);
        canvas.addEventListener('mouseleave', finishDraw);

        // Buttons
        toggleDrawBtn.addEventListener('click', () => setDrawMode(!state.drawMode));
        undoBtn.addEventListener('click', () => {
          if (state.regions.length > 0) {
            state.regions.pop();
            updateUI();
            drawCanvas();
          }
        });
        clearBtn.addEventListener('click', () => {
          state.regions = [];
          updateUI();
          drawCanvas();
        });
        processBtn.addEventListener('click', async () => {
          if (state.regions.length === 0 || !state.videoId) {
            alert('Please mark at least one region');
            return;
          }
          
          if (!state.backendConnected) {
            alert('Backend is not connected. Please start the backend server.');
            return;
          }
          
          state.isProcessing = true;
          state.outputReady = false;
          progressSection.style.display = '';
          updateUI();
          
          try {
            // Start processing
            const resp = await fetch(`${BACKEND_URL}/process`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ video_id: state.videoId, regions: state.regions }),
            });
            
            if (!resp.ok) {
              let detail = '';
              try { detail = await resp.text(); } catch (_) {}
              alert('Failed to process video: ' + detail);
              progressSection.style.display = 'none';
              return;
            }
            
            const data = await resp.json();
            state.outputId = data.output_id;
            
            // Connect to progress stream
            state.progressEventSource = new EventSource(`${BACKEND_URL}/progress/${state.outputId}`);
            
            state.progressEventSource.onmessage = (event) => {
              const progress = JSON.parse(event.data);
              
              progressBar.style.width = progress.progress + '%';
              progressBar.textContent = progress.progress + '%';
              
              if (progress.stage === 'inpainting') {
                progressText.textContent = `Processing frame ${progress.current_frame} of ${progress.total_frames}...`;
              } else if (progress.stage === 'assembling') {
                progressText.textContent = 'Assembling video...';
              }
              
              if (progress.status === 'completed') {
                state.progressEventSource.close();
                state.outputReady = true;
                progressText.textContent = 'Processing complete!';
                updateUI();
                setTimeout(() => {
                  progressSection.style.display = 'none';
                  alert('Video processed successfully!');
                }, 1000);
              } else if (progress.status === 'error') {
                state.progressEventSource.close();
                progressSection.style.display = 'none';
                state.outputReady = false;
                alert('Processing failed: ' + (progress.error || 'Unknown error'));
              }
            };
            
            state.progressEventSource.onerror = () => {
              state.progressEventSource.close();
              progressSection.style.display = 'none';
              alert('Lost connection to progress stream');
            };
            
          } catch (err) {
            alert('Failed to process video: ' + (err && err.message || err));
            progressSection.style.display = 'none';
          } finally {
            state.isProcessing = false;
            updateUI();
          }
        });
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
          if (state.progressEventSource) {
            state.progressEventSource.close();
          }
        });
      })();
    </script>
  </body>
</html>